---
title: "03_merge_data_from_sources"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Define processing function
process_khv_dataframe <- function(df) {
  if ("PLZ" %in% colnames(df)) {
    df <- dplyr::mutate(df, Postleitzahl = as.character(PLZ))
  } else if ("Adresse_Postleitzahl_Standort" %in% colnames(df)) {
    df <- dplyr::mutate(df, Postleitzahl = as.character(Adresse_Postleitzahl_Standort))
  } else if ("Adresse _Zustellbezogene Postleitzahl und Ort" %in% colnames(df)) {
    df <- dplyr::mutate(df, Postleitzahl = stringr::str_extract(`Adresse _Zustellbezogene Postleitzahl und Ort`, "\\d{5}"))
  } else {
    df <- dplyr::mutate(df, Postleitzahl = NA_character_)
  }
  
  if ("EinrichtungsTyp" %in% colnames(df)) {
    df <- dplyr::filter(df, EinrichtungsTyp == 2)
  } else if ("Art" %in% colnames(df)) {
    df <- dplyr::filter(df, Art == 2)
  }

  return(df)
}

# Process all KHV geocoded datasets
processed_khv_list <- purrr::map(list_khv_geocoded, process_khv_dataframe)
```

```{r match_closures_to_khv}
# Match closure postal codes to KHV data

df_hospital_closures_combined_geocoded_continue_match_KHV <- df_hospital_closures_info_combined %>%
  dplyr::mutate(
    match_found = purrr::map_lgl(Postleitzahl, function(plz) {
      any(purrr::map_lgl(processed_khv_list, function(df) plz %in% df$Postleitzahl))
    }),
    matching_dfs = purrr::map_chr(Postleitzahl, function(plz) {
      matched <- purrr::imap_chr(processed_khv_list, function(df, name) {
        if (plz %in% df$Postleitzahl) name else NA_character_
      })
      paste(na.omit(matched), collapse = "; ")
    })
  )
```

### Import Manual Research Data on Last Match to KHV Register

```{r import_manual_match_data}
# Read manually confirmed last matches file
file_path_manual_match <- here::here("data", "supplementary_files", "hospital_closures_match_khv_register_plankrankenhaus.txt")

lines_manual_match <- readLines(file_path_manual_match)

# Parse lines into dataframe
df_hospital_closures_last_match_khv_plankrankenhaus <- tibble::tibble(
  Postleitzahl = stringr::str_extract(lines_manual_match, "^[0-9]+"),
  info_last_match_khv = stringr::str_trim(stringr::str_remove(lines_manual_match, "^[0-9]+\\s+"))
) %>%
  dplyr::mutate(
    year_last_match_khv_confirmed = as.integer(stringr::str_extract(info_last_match_khv, "\\d{4}"))
  )
```

---

### Merge Confirmed Matches into Closure Data

```{r merge_manual_closure_matches}
# Merge manually confirmed matches with closures

df_hospital_closures_combined_geocoded_continue_match_KHV_updated <- df_hospital_closures_combined_geocoded_continue_match_KHV %>%
  dplyr::left_join(
    df_hospital_closures_last_match_khv_plankrankenhaus %>%
      dplyr::select(Postleitzahl, info_last_match_khv, year_last_match_khv_confirmed),
    by = "Postleitzahl",
    multiple = "any"
  )
```

---

### Filter Confirmed Closures and Excluded Cases

```{r filter_confirmed_and_excluded}
# Filter confirmed and excluded closures

df_confirmed_closures <- df_hospital_closures_combined_geocoded_continue_match_KHV_updated %>%
  dplyr::filter(!is.na(year_last_match_khv_confirmed) & !is.na(year_of_closure))

df_excluded_closures <- df_hospital_closures_combined_geocoded_continue_match_KHV_updated %>%
  dplyr::filter(!is.na(year_last_match_khv_confirmed) & is.na(year_of_closure))

# Print counts
cat("Confirmed closures:", nrow(df_confirmed_closures), "\n")
cat("Excluded closures (uncertain closure year):", nrow(df_excluded_closures), "\n")

# Define study years
years_own_study <- 2010:2020
```

```{r}
df_excluded_closures_ARS <- df_excluded_closures %>%
  dplyr::mutate(IK_Institutionskennzeichen = as.character(IK_Institutionskennzeichen)) %>%
  dplyr::left_join(
    df_hospitals_with_gemeinde %>%
      dplyr::mutate(IK_Institutionskennzeichen = as.character(IK_Institutionskennzeichen)) %>%
      dplyr::select(
        IK_Institutionskennzeichen,
        Standortnummer,
        year,
        ARS
      ),
    by = c("IK_Institutionskennzeichen", "Standortnummer", "year"),
    multiple = "any"
  )

```


---

```{r visualization_of_closures}
# Define the years covered in each study and statistics
all_years_of_data <- 2003:2023
years_preusker <- 2003:2013

# Extract number of confirmed closures from own research (convert to numeric and ensure all years are covered)
own_research_closures <- table(df_confirmed_closures$year_of_closure) * -1

# Convert to a named numeric vector with all years explicitly included (default missing years to 0)
own_research_closures_full <- setNames(rep(0, length(all_years_of_data)), all_years_of_data)
own_research_closures_full[names(own_research_closures)] <- own_research_closures

# Official hospital numbers (2002-2023)
official_hospital_numbers <- c(
  2221, 2197, 2166, 2139, 2104, 2087, 2083, 2084, 2064, 2045, 2017, 1996, 
  1980, 1956, 1951, 1942, 1925, 1914, 1903, 1887, 1893, 1874
)

# Compute annual net change in the number of hospitals (official statistics)
official_hospital_numbers_annual_change <- diff(official_hospital_numbers)

# Define confirmed closures as per Preusker et al.
preusker_closures <- c(
  -12, -10, -4, -7, -8, -1, -5, -4, -7, -10, -6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
)

# Create dataframe with years 2003-2023
df_hospital_closure_analysis <- tibble::tibble(
  Year = all_years_of_data,
  `Official Net Change` = official_hospital_numbers_annual_change,
  `Confirmed Closures Preusker (2003–13)` = preusker_closures,
  `Confirmed Closures Own Research (2010–20)` = as.numeric(own_research_closures_full[as.character(all_years_of_data)])
)

# Convert dataframe to long format for visualization
df_hospital_closure_analysis_long <- df_hospital_closure_analysis %>%
  tidyr::pivot_longer(cols = -Year, names_to = "Statistic", values_to = "Change") %>%
  tidyr::drop_na()

# Create a histogram to compare all three statistics
plot_hospital_closures_source_comparison <- ggplot2::ggplot(df_hospital_closure_analysis_long, ggplot2::aes(x = Year, y = Change, fill = Statistic)) +
  ggplot2::geom_col(position = "dodge", width = 0.7) +
  ggplot2::theme_minimal() +
  ggplot2::scale_fill_manual(
    values = c4a("brewer.dark2", n = 3)
  ) +
  ggplot2::scale_y_continuous(
    breaks = seq(-50, 10, by = 5),
    minor_breaks = NULL
  ) +
  ggplot2::scale_x_continuous(
    limits = c(2002.5, 2020.5),
    breaks = seq(2003, 2020, by = 1),
    minor_breaks = NULL
  ) +
  ggplot2::labs(
    title = NULL,
    x = "Year",
    y = "Annual Change in Hospital Numbers",
    fill = NULL
  ) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1)) +
  ggplot2::theme(
    legend.position = "bottom",
    legend.text = ggplot2::element_text(size = 14),
    axis.title = ggplot2::element_text(size = 14),
    axis.text = ggplot2::element_text(size = 12)
  )

# Print plot
print(plot_hospital_closures_source_comparison)

# Commented out: Save the plot manually later
# ggplot2::ggsave("images/plot_hospital_closures_confirmed.png", width = 12, height = 5, dpi = 300)
```

```{r summarize_closure_ratios}
# Extract relevant subsets from the dataset
preusker_closures_subset <- df_hospital_closure_analysis %>%
  dplyr::filter(Year %in% years_preusker) %>%
  dplyr::summarise(total_preusker_closures = sum(`Confirmed Closures Preusker (2003–13)`, na.rm = TRUE))

own_closures_subset <- df_hospital_closure_analysis %>%
  dplyr::filter(Year %in% years_own_study) %>%
  dplyr::summarise(total_own_closures = sum(`Confirmed Closures Own Research (2010–20)`, na.rm = TRUE))

# Extract net change in hospital numbers from official statistics
official_net_change_preusker <- df_hospital_closure_analysis %>%
  dplyr::filter(Year %in% years_preusker) %>%
  dplyr::summarise(total_official_change_preusker = sum(`Official Net Change`, na.rm = TRUE))

official_net_change_own <- df_hospital_closure_analysis %>%
  dplyr::filter(Year %in% years_own_study) %>%
  dplyr::summarise(total_official_change_own = sum(`Official Net Change`, na.rm = TRUE))

# Compute the ratios
ratio_preusker <- preusker_closures_subset$total_preusker_closures / abs(official_net_change_preusker$total_official_change_preusker)
ratio_own <- own_closures_subset$total_own_closures / abs(official_net_change_own$total_official_change_own)

# Print results
cat("Ratio of Preusker-confirmed closures to official net change (2003-2013):", round(ratio_preusker, 2), "\n")
cat("Ratio of own-confirmed closures to official net change (2010-2020):", round(ratio_own, 2), "\n")
```


```{r Match Hospitals to Municipalities}
# Convert hospital locations to sf object
hospitals_sf <- sf::st_as_sf(
  df_hospital_location_merged_geocoded,
  coords = c("longitude", "latitude"),
  crs = 4326
)

# Transform CRS to match municipality shapefile
hospitals_sf_transformed <- sf::st_transform(
  hospitals_sf,
  sf::st_crs(shp_gemeinde)
)

# Spatial join hospitals with municipalities
hospitals_with_gemeinde <- sf::st_join(
  hospitals_sf_transformed,
  shp_gemeinde,
  join = sf::st_intersects
)

# Transform hospitals back to WGS 84 (optional)
hospitals_with_gemeinde <- sf::st_transform(
  hospitals_with_gemeinde,
  4326
)

# Extract coordinates and select relevant columns
hospitals_with_gemeinde <- hospitals_with_gemeinde %>%
  dplyr::mutate(
    longitude = sf::st_coordinates(.)[, 1],
    latitude = sf::st_coordinates(.)[, 2]
  ) %>%
  dplyr::select(
    Name,
    IK_Institutionskennzeichen,
    Standortnummer,
    Standortnummer_alt,
    year,
    Adresse,
    longitude,
    latitude,
    ARS
  )

# Convert to regular data frame
df_hospitals_with_gemeinde <- as.data.frame(hospitals_with_gemeinde)

```

```{r Combine Confirmed Hospital Closures with Municipal and RegioStaR Data}
df_confirmed_closures_ARS <- df_confirmed_closures %>%
  dplyr::mutate(IK_Institutionskennzeichen = as.factor(IK_Institutionskennzeichen)) %>%
  dplyr::left_join(
    df_hospitals_with_gemeinde %>%
      dplyr::mutate(IK_Institutionskennzeichen = as.factor(IK_Institutionskennzeichen)) %>%
      dplyr::select(
        IK_Institutionskennzeichen,
        Standortnummer,
        year,
        ARS
      ),
    by = c("IK_Institutionskennzeichen", "Standortnummer", "year")
  ) %>%
  dplyr::left_join(
    df_regiostar_geo %>%
      dplyr::select(
        ARS,
        RegioStaR2,
        RegioStaR4,
        RegioStaR4from5,
        RegioStaR5,
        RegioStaR6from7,
        RegioStaR7,
        RegioStaR17
      ),
    by = "ARS"
  ) %>%
  dplyr::mutate(ARS = as.factor(ARS))

```

```{r}
# Define years of interest
selected_years <- as.character(2009:2019)

# Check distribution in RegioStaR types
table(df_regiostar_complete$RegioStaR4from5)
table(df_confirmed_closures_ARS$RegioStaR4from5)

# Count treated hospitals by RegioStaR for selected years
treated_filtered_counts <- df_confirmed_closures_ARS %>%
  dplyr::filter(year_of_closure %in% selected_years) %>%
  dplyr::pull(RegioStaR4from5) %>%
  table()

# Count all treated hospitals
treated_counts <- table(df_confirmed_closures_ARS$RegioStaR4from5)

# Count all hospitals (denominator)
total_counts <- table(df_regiostar_complete$RegioStaR4from5)

# Calculate ratios
treated_ratio <- treated_counts / total_counts
treated_ratio_filtered <- treated_filtered_counts / total_counts

# Display
treated_ratio
treated_ratio_filtered

```

```{r}
# Recode RegioStaR4from5 to descriptive labels
df_plot_map_hospital_closures_municipality <- df_regiostar_geo %>%
  dplyr::mutate(
    RegioStaR4from5 = dplyr::case_when(
      RegioStaR4from5 == "51/52" ~ "Urban Region - Metropolis / Large City",
      RegioStaR4from5 == "53" ~ "Urban Region - Surrounding Area",
      RegioStaR4from5 == "54" ~ "Rural Region - City or Urban Area",
      RegioStaR4from5 == "55" ~ "Rural Region - Small-Town Area or Village Area",
      TRUE ~ RegioStaR4from5
    )
  )

# Define the color variable for closure years
var_color <- "year_of_closure"

# Create the plot
plot_map_hospital_closures_municipality <- ggplot2::ggplot(data = df_plot_map_hospital_closures_municipality) +
  ggplot2::geom_sf(ggplot2::aes(color = as.factor(RegioStaR4from5)), color = "black", fill = NA, linewidth = 0.01) +
  ggplot2::geom_sf(ggplot2::aes(fill = as.factor(RegioStaR4from5)), color = NA, alpha = 0.8) +
  ggplot2::geom_sf(data = states_border_clean_sf, color = "black", fill = NA, linewidth = 0.5) +
  ggplot2::geom_sf(data = df_internal_borders, color = "black", fill = NA, linewidth = 0.5) +
  ggplot2::geom_point(
    data = df_confirmed_closures %>% dplyr::filter(year_of_closure %in% c("2010", "2011", "2012", "2013", "2014", "2015", "2016", "2017", "2018", "2019", "2020")),
    ggplot2::aes(x = longitude, y = latitude, fill = .data[[var_color]]),
    shape = 21, stroke = 0.5, size = 1.75
  ) +
  ggplot2::scale_fill_manual(
    values = c(
      # "2020" = "#8DD3C7",
      # "2019" = "#FFFFB3",
      # "2018" = "#BEBADA",
      # "2017" = "#FB8072",
      # "2016" = "#80B1D3",
      # "2015" = "#FDB462",
      # "2014" = "#B3DE69",
      # "2013" = "#FCCDE5",
      # "2012" = "#D9D9D9",
      # "2011" = "#BC80BD",
      # "2010" = "#CCEBC5",
      
      "2020" = "darkgrey",
      "2019" = "orange",
      "2018" = "purple",
      "2017" = "yellow",
      "2016" = "deepskyblue",
      "2015" = "magenta",
      "2014" = "chartreuse",
      "2013" = "darkblue",
      "2012" = "red",
      "2011" = "brown",
      "2010" = "white",
      
      "Urban Region - Surrounding Area" = colorspace::lighten("#6A3D9A", amount = 0.8),
      "Urban Region - Metropolis / Large City" = "#6A3D9A",
      "Rural Region - Small-Town Area or Village Area" = colorspace::lighten("#B15928", amount = 0.8),
      "Rural Region - City or Urban Area" = "#B15928"
    )
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(
    panel.grid = ggplot2::element_blank(),
    axis.text = ggplot2::element_blank(),
    axis.ticks = ggplot2::element_blank(),
    panel.border = ggplot2::element_blank(),
    legend.position = "right"
  ) +
  ggplot2::labs(
    title = NULL,
    fill = "Municipality Type / Year of Hospital Closure",
    x = NULL,
    y = NULL
  )

# Commented out: Save plot manually later
# ggplot2::ggsave("images/plot_map_hospital_closures_confirmed_municipality_type.pdf",
#   plot = plot_map_hospital_closures_municipality,
#   device = cairo_pdf,
#   width = 8, height = 6
# )

# Display plot
plot_map_hospital_closures_municipality

```

```{r Combine Dependent Variables with Municipality Shapes}
# Prepare employment data merged with municipality shapes
df_dependent_variables_shapes <- df_dependent_variables %>%
  dplyr::mutate(
    ARS = stringr::str_pad(as.character(ARS), width = 12, pad = "0")  # Ensure ARS codes are 12 digits
  ) %>%
  dplyr::inner_join(
    df_regiostar_geo,
    by = "ARS"
  ) %>%
  dplyr::mutate(
    hospital_closure = ARS %in% df_confirmed_closures_ARS$ARS
  )

# Combine hospital closure data with employment variables
df_combined_hospital_data_employment <- df_confirmed_closures_ARS %>%
  dplyr::mutate(
    ARS = stringr::str_pad(as.character(ARS), width = 12, pad = "0")
  ) %>%
  dplyr::select(
    -dplyr::starts_with("Regio")  # Drop RegioStaR columns from closures (will come from municipality data)
  ) %>%
  dplyr::right_join(
    df_dependent_variables_shapes,
    by = "ARS"
  ) %>%
  dplyr::rename(
    geometry_hospital = geometry.x,
    geometry_municipality = geometry.y
  )

# Check outputs
head(df_dependent_variables_shapes)
head(df_combined_hospital_data_employment)

# Optional: Check ARS code lengths
table(nchar(unique(as.character(df_dependent_variables$ARS))))
table(nchar(unique(as.character(df_dependent_variables_shapes$ARS))))

```

```{r}
df_regiostar_complete_closure_indicated_unclear_defined <- df_regiostar_geo %>%
  dplyr::mutate(
    hospital_closure = dplyr::if_else(ARS %in% df_confirmed_closures_ARS$ARS, TRUE, FALSE),
    unclear_hospital_closure = dplyr::if_else(ARS %in% df_excluded_closures_ARS$ARS, TRUE, FALSE)
  ) %>%
  dplyr::mutate(
    binary_potential_hospital_closure = dplyr::case_when(
      unclear_hospital_closure ~ TRUE,
      hospital_closure ~ TRUE,
      TRUE ~ FALSE
    ),
    non_binary_potential_hospital_closure = dplyr::case_when(
      unclear_hospital_closure ~ "Unclear Treatment Status",
      hospital_closure ~ "Treated",
      TRUE ~ "Control"
    )
  )

```


```{r}
# Prepare unique municipality dataset
df_CS_model_preparation_unique <- df_regiostar_complete_closure_indicated_unclear_defined %>%
  dplyr::distinct(ARS, .keep_all = TRUE) %>%
  dplyr::filter(!sf::st_is_empty(geometry))  # Exclude empty geometries

# Build neighborhood structure (queen contiguity)
nb_unique <- spdep::poly2nb(df_CS_model_preparation_unique$geometry, queen = TRUE)

# Convert neighborhood structure to adjacency matrix
adjacency_matrix_unique <- spdep::nb2mat(nb_unique, style = "B", zero.policy = TRUE)

# Create treatment and spillover indicators
df_prep_spillover_unique <- df_CS_model_preparation_unique %>%
  dplyr::mutate(
    treated_unit = binary_potential_hospital_closure,
    neighbors = purrr::map(1:nrow(adjacency_matrix_unique), ~ which(adjacency_matrix_unique[.x, ] == 1)),
    spillover_unit = purrr::map_lgl(neighbors, ~ any(treated_unit[.x] == 1)),
    treatment_status_spillover = dplyr::case_when(
      treated_unit ~ "direct_treated",
      spillover_unit ~ "spillover",
      TRUE ~ "control"
    ),
    treatment_status_spillover = dplyr::if_else(
      non_binary_potential_hospital_closure == "Unclear Treatment Status",
      "unclear treatment status",
      treatment_status_spillover
    )
  )

# Merge treatment status with employment dataset
df_combined_hospital_data_employment_enriched <- df_combined_hospital_data_employment %>%
  dplyr::left_join(
    df_prep_spillover_unique %>%
      dplyr::distinct(ARS, treatment_status_spillover),
    by = "ARS"
  )

# Print overview
table(
  df_combined_hospital_data_employment_enriched %>%
    dplyr::distinct(ARS, .keep_all = TRUE) %>%
    dplyr::pull(treatment_status_spillover)
)

table(df_prep_spillover_unique$treatment_status_spillover)

```

```{r}
# Prepare municipality dataset for plotting
df_plot_map_treatment_spillover_municipality <- df_combined_hospital_data_employment_enriched %>%
  dplyr::mutate(
    treatment_status_spillover = dplyr::case_when(
      treatment_status_spillover == "direct_treated" ~ "Unit With Direct Treatment",
      treatment_status_spillover == "control" ~ "Control Unit",
      treatment_status_spillover == "spillover" ~ "(Potential) Spillover Unit",
      treatment_status_spillover == "unclear treatment status" ~ "Unit With Unclear Treatment Status"
    )
  )

# Create spillover map
plot_map_treatment_spillover_municipality <- ggplot2::ggplot(
  data = df_plot_map_treatment_spillover_municipality %>%
    dplyr::distinct(ARS, .keep_all = TRUE)
) +
  ggplot2::geom_sf(data = df_plot_map_hospital_closures_municipality %>%
                     dplyr::distinct(ARS, .keep_all = TRUE),
                   ggplot2::aes(color = as.factor(RegioStaR4from5)),
                   color = "grey80", fill = NA, linewidth = 0.00001) +
  ggplot2::geom_sf(ggplot2::aes(fill = treatment_status_spillover, geometry = geometry_municipality)) +
  ggplot2::geom_sf(data = states_border_clean_sf, color = "black", fill = NA, linewidth = .5) +
  ggplot2::geom_sf(data = df_internal_borders, color = "black", fill = NA, linewidth = .5) +
  ggplot2::theme_minimal() +
  ggplot2::theme(
    panel.grid = ggplot2::element_blank(),
    axis.text = ggplot2::element_blank(),
    axis.ticks = ggplot2::element_blank(),
    panel.border = ggplot2::element_blank(),
    legend.position = "right"
  ) +
  ggplot2::scale_fill_manual(values = c(
    "Unit With Direct Treatment" = "#88CCEE",
    "Control Unit" = "#117733",
    "(Potential) Spillover Unit" = "#DDCC77",
    "Unit With Unclear Treatment Status" = "#CC6677"
    # alternative suggestion for fill: "brewer.dark2" if desired
  )) +
  ggplot2::labs(
    title = NULL,
    fill = "Classification of Municipalities \n(With Sufficient Data)"
  )

# Print plot
print(plot_map_treatment_spillover_municipality)

# Commented out: Save manually later
# ggplot2::ggsave("images/plot_map_treatment_spillover_control.pdf", plot = plot_map_treatment_spillover_municipality, width = 8, height = 6)

```

```{r Callaway, Sant’Anna Difference-in-Differences (DiD) Setup}
# Prepare dataframe for Callaway & Sant'Anna DiD estimation
df_CS_model_preparation <- df_combined_hospital_data_employment_enriched %>%
  dplyr::filter(
    treatment_status_spillover %in% c("control", "direct_treated")
  ) %>%
  dplyr::mutate(
    ARS = as.numeric(ARS),
    year_of_closure = as.numeric(as.character(year_of_closure)),
    year_of_closure = dplyr::if_else(is.na(year_of_closure), 0, year_of_closure)
  )

```




```{r}
# Add hospital closure indicator
df_regiostar_complete_closure_indicated <- df_regiostar_complete %>%
  dplyr::mutate(
    hospital_closure = ARS %in% df_confirmed_closures_ARS$ARS
  )

# Build demographic distribution for full sample
df_demographic_distribution_full_data <- df_regiostar_complete_closure_indicated %>%
  sf::st_drop_geometry() %>%
  dplyr::filter(!is.na(RegioStaR6from7)) %>%
  dplyr::distinct(ARS, .keep_all = TRUE) %>%
  dplyr::group_by(RegioStaR6from7, hospital_closure) %>%
  dplyr::summarise(count = dplyr::n(), .groups = "drop") %>%
  tidyr::pivot_wider(names_from = hospital_closure, values_from = count, values_fill = 0) %>%
  dplyr::rename(
    Control = `FALSE`,
    Treated = `TRUE`
  ) %>%
  dplyr::mutate(
    Total = Control + Treated,
    Treated_Share_Municipality = scales::percent(Treated / Total, accuracy = 0.01),
    Treated_Share_Treated = scales::percent(Treated / sum(Treated), accuracy = 0.01)
  ) %>%
  dplyr::mutate(
    Municipality_Type = dplyr::case_when(
      RegioStaR6from7 == "71/72" ~ "Metropolis, Regiopolis or Large City (Urban Region)",
      RegioStaR6from7 == "73"    ~ "Medium-Sized City (Urban Region)",
      RegioStaR6from7 == "74"    ~ "Small-Town / Village Area (Urban Region)",
      RegioStaR6from7 == "75"    ~ "Central City (Rural Region)",
      RegioStaR6from7 == "76"    ~ "Medium-Sized City (Rural Region)",
      RegioStaR6from7 == "77"    ~ "Small-Town / Village Area (Rural Region)",
      TRUE ~ RegioStaR6from7
    )
  ) %>%
  dplyr::select(
    Municipality_Type, Control, Treated, Total, Treated_Share_Municipality, Treated_Share_Treated
  ) %>%
  dplyr::mutate(Sample = "Full Dataset")

```

```{r}
# Build demographic distribution for DiD sample
df_demographic_distribution_did <- df_CS_model_preparation %>%
  dplyr::filter(Year < 2021) %>%
  dplyr::filter(!is.na(RegioStaR6from7)) %>%
  dplyr::distinct(ARS, .keep_all = TRUE) %>%
  dplyr::group_by(RegioStaR6from7, hospital_closure) %>%
  dplyr::summarise(count = dplyr::n(), .groups = "drop") %>%
  tidyr::pivot_wider(names_from = hospital_closure, values_from = count, values_fill = 0) %>%
  dplyr::rename(
    Control = `FALSE`,
    Treated = `TRUE`
  ) %>%
  dplyr::mutate(
    Total = Control + Treated,
    Treated_Share_Municipality = scales::percent(Treated / Total, accuracy = 0.01),
    Treated_Share_Treated = scales::percent(Treated / sum(Treated), accuracy = 0.01)
  ) %>%
  dplyr::mutate(
    Municipality_Type = dplyr::case_when(
      RegioStaR6from7 == "71/72" ~ "Metropolis, Regiopolis or Large City (Urban Region)",
      RegioStaR6from7 == "73"    ~ "Medium-Sized City (Urban Region)",
      RegioStaR6from7 == "74"    ~ "Small-Town / Village Area (Urban Region)",
      RegioStaR6from7 == "75"    ~ "Central City (Rural Region)",
      RegioStaR6from7 == "76"    ~ "Medium-Sized City (Rural Region)",
      RegioStaR6from7 == "77"    ~ "Small-Town / Village Area (Rural Region)",
      TRUE ~ RegioStaR6from7
    )
  ) %>%
  dplyr::select(
    Municipality_Type, Control, Treated, Total, Treated_Share_Municipality, Treated_Share_Treated
  ) %>%
  dplyr::mutate(Sample = "DiD Sample Only")

```

```{r}
# Combine both tables for comparison
df_combined_demographic_distribution <- dplyr::bind_rows(
  df_demographic_distribution_full_data,
  df_demographic_distribution_did
) %>%
  dplyr::arrange(Municipality_Type, dplyr::desc(Sample))  # Sort nicely

df_combined_demographic_distribution
```

```{r}
# Create bracketed summary table
df_bracket_approach <- df_demographic_distribution_full_data %>%
  dplyr::rename_with(~ paste0(.x, "_full"), -Municipality_Type) %>%
  dplyr::inner_join(
    df_demographic_distribution_did %>%
      dplyr::rename_with(~ paste0(.x, "_did"), -Municipality_Type),
    by = "Municipality_Type"
  ) %>%
  dplyr::mutate(
    `Without Hospital Closure` = paste0(`Control_full`, " (", `Control_did`, ")"),
    `With Hospital Closure` = paste0(`Treated_full`, " (", `Treated_did`, ")"),
    `Total` = paste0(`Total_full`, " (", `Total_did`, ")"),
    `Share with Hospital Closures` = paste0(`Treated_Share_Municipality_full`, " (", `Treated_Share_Municipality_did`, ")"),
    `Share of Hospital Closures` = paste0(`Treated_Share_Treated_full`, " (", `Treated_Share_Treated_did`, ")")
  ) %>%
  dplyr::select(
    Municipality_Type,
    `Without Hospital Closure`,
    `With Hospital Closure`,
    `Total`,
    `Share with Hospital Closures`,
    `Share of Hospital Closures`
  )

df_bracket_approach
```

### Excurse: Visualizing Parallel Trends

```{r}
# Prepare data: Compute average employment levels per year, separated by municipality type
df_parallel_trends <- df_CS_model_preparation %>%
  dplyr::filter(Year < 2021) %>%
  dplyr::group_by(ARS) %>%
  dplyr::filter(
    all(!is.na(employment_level)),  
    all(!is.na(employment_level_female))
  ) %>%
  dplyr::ungroup() %>%
  dplyr::filter(treatment_status_spillover %in% c("direct_treated", "control")) %>%
  dplyr::mutate(
    treated_pre = dplyr::if_else(treatment_status_spillover == "direct_treated" & Year < year_of_closure, "Treated (Pre-Treatment)", NA_character_),
    group = dplyr::case_when(
      treatment_status_spillover == "control" ~ "Non-Treated",
      treatment_status_spillover == "direct_treated" & Year < year_of_closure ~ "Treated (Pre-Treatment)"
    )
  ) %>%
  dplyr::filter(!is.na(group)) %>%
  dplyr::group_by(Year, group, RegioStaR4from5) %>%
  dplyr::summarise(
    employment = mean(employment_level, na.rm = TRUE),
    employment_female = mean(employment_level_female, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  tidyr::pivot_longer(cols = c(employment, employment_female), 
                      names_to = "Employment_Type", 
                      values_to = "Employment_Value") %>%
  dplyr::rename(identifier = group) %>%
  dplyr::mutate(
    Employment_Type = dplyr::case_when(
      Employment_Type == "employment" ~ "Overall Employment",
      Employment_Type == "employment_female" ~ "Female Employment"
    ),
    RegioStaR4from5 = dplyr::case_when(
      RegioStaR4from5 == "51/52" ~ "Urban Region: \nMetropolis, \nLarge City",
      RegioStaR4from5 == "53" ~ "Urban Region: \nSurrounding Area",
      RegioStaR4from5 == "54" ~ "Rural Region: \nCity, \nUrban Area",
      RegioStaR4from5 == "55" ~ "Rural Region: \nSmall-Town, \nVillage Area",
      TRUE ~ RegioStaR4from5
    )
  )

# Extract individual trajectories for treated units
df_individual_trajectories <- df_CS_model_preparation %>%
  dplyr::filter(treatment_status_spillover == "direct_treated") %>%
  dplyr::filter(Year < year_of_closure) %>%
  dplyr::select(ARS, Year, employment_level, employment_level_female, RegioStaR4from5) %>%
  tidyr::pivot_longer(cols = c(employment_level, employment_level_female), 
                      names_to = "Employment_Type", 
                      values_to = "Employment_Value") %>%
  dplyr::rename(identifier = ARS) %>%
  dplyr::mutate(
    Employment_Type = dplyr::case_when(
      Employment_Type == "employment_level" ~ "Overall Employment",
      Employment_Type == "employment_level_female" ~ "Female Employment"
    ),
    RegioStaR4from5 = dplyr::case_when(
      RegioStaR4from5 == "51/52" ~ "Urban Region: \nMetropolis, \nLarge City",
      RegioStaR4from5 == "53" ~ "Urban Region: \nSurrounding Area",
      RegioStaR4from5 == "54" ~ "Rural Region: \nCity, \nUrban Area",
      RegioStaR4from5 == "55" ~ "Rural Region: \nSmall-Town, \nVillage Area",
      TRUE ~ RegioStaR4from5
    )
  )

# Plot parallel trends
plot_parallel_trends_complete <- ggplot2::ggplot() +
  ggplot2::geom_line(
    data = df_individual_trajectories, 
    ggplot2::aes(x = Year, y = Employment_Value, group = identifier),
    color = "gray50", alpha = 0.4, linewidth = 0.75
  ) +
  ggplot2::geom_line(
    data = df_parallel_trends,
    ggplot2::aes(x = Year, y = Employment_Value, color = identifier, group = identifier),
    linewidth = 1
  ) +
  ggplot2::geom_point(
    data = df_parallel_trends,
    ggplot2::aes(x = Year, y = Employment_Value, color = identifier, group = identifier),
    size = 2.5
  ) +
  ggplot2::facet_grid(Employment_Type ~ RegioStaR4from5) +
  ggplot2::labs(
    title = NULL,
    subtitle = NULL,
    caption = "Gray lines represent individual treated units until closure occurrence",
    x = "Year",
    y = "Average Employment Level",
    color = "Group"
  ) +
  ggplot2::scale_color_manual(
    values = c4a(palette = "brewer.dark2")
  ) +
  ggplot2::scale_y_continuous(
    labels = scales::label_percent(scale = 1)
  ) +
  ggplot2::scale_x_continuous(
    breaks = seq(2010, 2020, by = 5),
    minor_breaks = seq(2005, 2020, by = 1)
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(
    legend.position = "bottom",
    legend.title = ggplot2::element_text(size = 14),
    legend.text = ggplot2::element_text(size = 14),
    axis.title = ggplot2::element_text(size = 14),
    axis.text = ggplot2::element_text(size = 12),
    strip.text = ggplot2::element_text(size = 12, face = "bold"),
    plot.caption = ggplot2::element_text(size = 12)
  )

# Print the plot
plot_parallel_trends_complete

# Commented out: Save manually later
# ggplot2::ggsave(
#   filename = "images/plot_parallel_trends.png",
#   plot = plot_parallel_trends_complete,
#   width = 8,
#   height = 6,
#   dpi = 300
# )

```

### Baseline DR Model Estimation
```{r}
# Step 1: Estimate ATT using Callaway-Sant'Anna's Difference-in-Differences method
CS_baseline_DR_results <- did::att_gt(
  yname = "employment_level",        # Outcome variable
  tname = "Year",                     # Time variable
  idname = "ARS",                     # Unit identifier
  gname = "year_of_closure",           # Treatment timing
  data = df_CS_model_preparation %>%
    dplyr::filter(year_of_closure < 2021), # Exclude closures after 2020
  xformla = ~ RegioStaR4from5,          # Covariates for DR estimation
  control_group = "nevertreated",       # Define control group
  anticipation = 0                     # No anticipation window
)

# Step 2: Compute dynamic ATT (effects by event time)
CS_baseline_DR_dynamic_effect <- did::aggte(
  CS_baseline_DR_results,
  type = "dynamic",
  max_e = 8,
  bstrap = TRUE,
  na.rm = TRUE
)

# Step 3: Compute simple average ATT
CS_baseline_DR_simple_effect <- did::aggte(
  CS_baseline_DR_results,
  type = "simple",
  bstrap = TRUE,
  na.rm = TRUE
)

# Step 4: Tidy dynamic ATT results for further usage
CS_baseline_DR_dynamic_data <- broom::tidy(CS_baseline_DR_dynamic_effect) %>%
  dplyr::mutate(
    time_periods = event.time,
    period = factor(
      dplyr::if_else(event.time < 0, "Pre-Treatment", "Post-Treatment"),
      levels = c("Pre-Treatment", "Post-Treatment")
    )
  )

# Step 5: Store results in a list for organized access later
CS_baseline_DR_results_combined <- list(
  att_model = CS_baseline_DR_results,
  dynamic_effect = CS_baseline_DR_dynamic_effect,
  simple_effect = CS_baseline_DR_simple_effect
)

# Output basic results
CS_baseline_DR_simple_effect
CS_baseline_DR_dynamic_data

```

```{r}
### Polished Plot of Dynamic ATT

# Step 1: Prepare data for plotting
df_did_full_DR <- broom::tidy(CS_baseline_DR_dynamic_effect) %>%
  dplyr::mutate(
    period = factor(
      dplyr::if_else(event.time < 0, "Pre-Treatment", "Post-Treatment"),
      levels = c("Pre-Treatment", "Post-Treatment")
    )
  )

# Step 2: Create dynamic ATT plot
plot_basic_DR <- ggplot2::ggplot(df_did_full_DR, ggplot2::aes(x = event.time, y = estimate, color = period)) +
  ggplot2::geom_point(size = 2) +
  ggplot2::geom_errorbar(ggplot2::aes(ymin = conf.low, ymax = conf.high), width = 0.3) +
  ggplot2::geom_hline(yintercept = 0, color = "black") +
  ggplot2::geom_vline(xintercept = 0, color = "black", linetype = "dashed", alpha = 0.2) +
  ggplot2::scale_color_manual(
    values = c(
      "Pre-Treatment" = "#855C75",
      "Post-Treatment" = "#D9AF6B"
    ),
    name = "Treatment Period",
    labels = c("Before Treatment", "After Treatment")
  ) +
  ggplot2::labs(
    title = NULL,
    x = "Years Relative to Treatment",
    y = "Average Treatment Effect (with 95% CI)"
  ) +
  ggplot2::scale_y_continuous(
    breaks = seq(-3, 1, by = 0.5),
    minor_breaks = seq(-3, 1, by = 0.25),
    labels = scales::label_percent(scale = 1)
  ) +
  ggplot2::scale_x_continuous(
    breaks = seq(-12, 8, by = 2),
    minor_breaks = seq(-13, 8, by = 1)
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(
    legend.position = "bottom"
    # Optional: You had originally commented out detailed legend sizing here
  )

# Display the plot
plot_basic_DR

# Commented out: Save manually later
# ggplot2::ggsave(
#   filename = "images/plot_basic_dr.jpg",
#   plot = plot_basic_DR,
#   width = 8,
#   height = 6,
#   dpi = 300
# )

```

```{r}
### Clean Table with Dynamic ATT Results

# Step 1: Tidy dynamic ATT results
table_dynamic_ATT <- broom::tidy(CS_baseline_DR_dynamic_effect) %>%
  dplyr::select(
    event.time, estimate, std.error,
    point.conf.low, conf.low,
    point.conf.high, conf.high
  ) %>%
  dplyr::mutate(
    dplyr::across(where(is.numeric), ~ round(.x, 3))
  ) %>%
  dplyr::rename(
    `Event Time` = event.time,
    `Estimate` = estimate,
    `Std. Error` = std.error,
    `95% CI Lower (Simultaneous)` = conf.low,
    `95% CI Upper (Simultaneous)` = conf.high,
    `95% CI Lower (Pointwise)` = point.conf.low,
    `95% CI Upper (Pointwise)` = point.conf.high
  )

# View cleaned table
print(table_dynamic_ATT)

# Commented out: Save or render LaTeX table manually later if needed
# knitr::kable(table_dynamic_ATT, caption = "Dynamic ATT Estimates Over Time")

```

### Basic Model OR (Outcome Regression Estimator)
```{r}
# Step 1: Estimate ATT using att_gt with OR method
CS_baseline_OR_results <- did::att_gt(
  yname = "employment_level",              
  tname = "Year",                          
  idname = "ARS",                          
  gname = "year_of_closure",               
  data = df_CS_model_preparation %>% 
    dplyr::filter(year_of_closure < 2021),        
  xformla = ~ RegioStaR4from5,             
  control_group = "nevertreated",          
  anticipation = 0,                        
  est_method = "OR"                         # Use outcome regression
)

# Step 2: Compute dynamic ATT
CS_baseline_OR_dynamic_effect <- did::aggte(
  CS_baseline_OR_results, 
  type = "dynamic",
  max_e = 8, 
  bstrap = TRUE,
  na.rm = TRUE
)

# Step 3: Compute simple overall ATT
CS_baseline_OR_simple_effect <- did::aggte(
  CS_baseline_OR_results,
  type = "simple",
  bstrap = TRUE,
  na.rm = TRUE
)

# Step 4: Tidy dynamic results for plotting
CS_baseline_OR_dynamic_data <- broom::tidy(CS_baseline_OR_dynamic_effect) %>%
  dplyr::mutate(
    time_periods = event.time,
    period = factor(
      dplyr::if_else(event.time < 0, "Pre-Treatment", "Post-Treatment"),
      levels = c("Pre-Treatment", "Post-Treatment")
    )
  )

# Step 5: Store for future use
CS_baseline_OR_results_combined <- list(
  att_model = CS_baseline_OR_results,
  dynamic_effect = CS_baseline_OR_dynamic_effect,
  simple_effect = CS_baseline_OR_simple_effect
)

# Output results
CS_baseline_OR_simple_effect
CS_baseline_OR_dynamic_data

```

```{r}
### Plotting Dynamic ATT (OR Estimation)

# Step 1: Create a pre/post treatment indicator
df_did_full_OR <- broom::tidy(CS_baseline_OR_dynamic_effect) %>%
  dplyr::mutate(
    period = factor(
      dplyr::if_else(event.time < 0, "Pre-Treatment", "Post-Treatment"),
      levels = c("Pre-Treatment", "Post-Treatment")
    )
  )

# Step 2: Create the plot
plot_basic_OR <- ggplot2::ggplot(df_did_full_OR, ggplot2::aes(x = event.time, y = estimate, color = period)) +
  
  ggplot2::geom_point(size = 2) +
  ggplot2::geom_errorbar(ggplot2::aes(ymin = conf.low, ymax = conf.high), width = 0.3) +
  ggplot2::geom_hline(yintercept = 0, color = "black") +
  ggplot2::geom_vline(xintercept = 0, color = "black", linetype = "dashed", alpha = 0.2) +
  
  ggplot2::scale_color_manual(
    values = c(
      "Pre-Treatment" = "#855C75",
      "Post-Treatment" = "#D9AF6B"
    ),
    name = "Treatment Period",
    labels = c("Before Treatment", "After Treatment")
  ) +
  
  ggplot2::labs(
    title = NULL,
    x = "Years Relative to Treatment",
    y = "Average Treatment Effect (with 95% CI)"
  ) +
  
  ggplot2::scale_y_continuous(
    breaks = seq(-3, 1, by = 0.5),
    minor_breaks = seq(-3, 1, by = 0.25),
    labels = scales::label_percent(scale = 1)
  ) +
  
  ggplot2::scale_x_continuous(
    breaks = seq(-12, 8, by = 2),
    minor_breaks = seq(-13, 8, by = 1)
  ) +
  
  ggplot2::theme_minimal() +
  ggplot2::theme(
    legend.position = "bottom"
  )

# Display the plot
plot_basic_OR

# Save the plot
# ggplot2::ggsave(
#   filename = "images/plot_basic_or.jpg",
#   plot = plot_basic_OR,
#   width = 8, height = 6,
#   dpi = 300
# )

```

### Balancing: Matching Before Weighting, Then Callaway-SantAnna

```{r}
# Step 1: Prepare unique dataset (one row per ARS)
df_unique_units <- df_CS_model_preparation %>%
  dplyr::group_by(ARS) %>% 
  dplyr::filter(all(!is.na(employment_level))) %>%   # Ensure complete employment_level data
  dplyr::ungroup() %>%
  dplyr::filter(Year < 2021) %>%
  dplyr::filter(!is.na(RegioStaR6from7)) %>%
  dplyr::filter(staff_doctors_nurses_numeric >= 10 | treatment_status_spillover == "control") %>%
  dplyr::distinct(ARS, .keep_all = TRUE) %>%
  dplyr::mutate(year_of_closure = as.numeric(year_of_closure))

# Step 2: Define matching parameters
n_runs <- 100
matching_ratio <- 6

# Step 3: Initialize storage
matched_datasets <- vector("list", n_runs)

# Step 4: Perform random matching within each demographic type
for (i in 1:n_runs) {
  
  set.seed(i * 100)  # Different seed each run
  
  matched_subsamples <- list()
  
  for (demo_type in unique(df_unique_units$RegioStaR6from7)) {
    
    df_subset <- df_unique_units %>% dplyr::filter(RegioStaR6from7 == demo_type)
    
    treated_units <- df_subset %>% dplyr::filter(treatment_status_spillover == "direct_treated")
    control_units <- df_subset %>% dplyr::filter(treatment_status_spillover == "control")
    
    num_treated <- nrow(treated_units)
    num_controls_needed <- num_treated * matching_ratio
    
    if (num_controls_needed > nrow(control_units)) {
      sampled_controls <- control_units
    } else {
      sampled_controls <- dplyr::slice_sample(control_units, n = num_controls_needed, replace = FALSE)
    }
    
    matched_subset <- dplyr::bind_rows(treated_units, sampled_controls)
    matched_subsamples[[demo_type]] <- matched_subset
  }
  
  df_matched <- dplyr::bind_rows(matched_subsamples)
  
  df_summary <- df_matched %>%
    dplyr::group_by(RegioStaR4from5, treatment_status_spillover) %>%
    dplyr::summarise(count = dplyr::n(), .groups = "drop") %>%
    tidyr::pivot_wider(names_from = treatment_status_spillover, values_from = count, values_fill = 0) %>%
    dplyr::rename(Control = control, Treated = direct_treated) %>%
    dplyr::mutate(
      Total = Control + Treated,
      Treated_Share = Treated / Total
    )
  
  matched_datasets[[i]] <- list(
    matched_data = df_matched,
    summary_stats = df_summary
  )
  
  print(paste("Randomized Matching Run", i, "completed."))
}

# Quick check
identical(matched_datasets[[5]], matched_datasets[[1]])  # Should return FALSE

```

```{r}
# Step 5: Prepare final datasets post-matching
final_datasets <- vector("list", length(matched_datasets))

for (i in seq_along(matched_datasets)) {
  
  df_weighted <- matched_datasets[[i]]$matched_data
  
  df_merged <- df_CS_model_preparation %>%
    dplyr::inner_join(
      df_weighted %>% dplyr::select(ARS, Year),
      by = "ARS"
    ) %>%
    dplyr::ungroup()
  
  final_datasets[[i]] <- df_merged
  
  print(paste("Final dataset preparation completed for run", i))
}

```

```{r}
# Step 6: Run Callaway-SantAnna models on each matched dataset
att_results_list <- vector("list", length(final_datasets))

for (i in seq_along(final_datasets)) {
  
  df_weighted <- final_datasets[[i]] %>%
    dplyr::mutate(year_of_closure = as.numeric(year_of_closure))
  
  att_model <- did::att_gt(
    yname = "employment_level",
    tname = "Year.x",
    idname = "ARS",
    gname = "year_of_closure",
    data = df_weighted,
    control_group = "nevertreated",
    xformla = ~ RegioStaR4from5,
    anticipation = 0,
    bstrap = FALSE,
    cband = FALSE
  )
  
  att_simple_effect <- did::aggte(
    att_model,
    type = "simple",
    bstrap = FALSE,
    na.rm = TRUE
  )
  
  att_dynamic_effect <- did::aggte(
    att_model,
    type = "dynamic",
    max_e = 8,
    na.rm = TRUE,
    bstrap = FALSE
  )
  
  att_results_list[[i]] <- list(
    att_model = att_model,
    simple_effect = att_simple_effect,
    dynamic_effect = att_dynamic_effect
  )
  
  print(paste("ATT model, simple ATT & dynamic ATT completed for dataset", i))
}

```

```{r}
# Step 7: Summarize Dynamic ATT Results
all_dynamic_results <- purrr::map_df(seq_along(att_results_list), function(i) {
  broom::tidy(att_results_list[[i]]$dynamic_effect) %>%
    dplyr::mutate(run = i)
})

all_dynamic_results <- all_dynamic_results %>%
  dplyr::rename(time_periods = event.time) %>%
  dplyr::mutate(
    period = factor(
      ifelse(time_periods < 0, "Pre-Treatment", "Post-Treatment"),
      levels = c("Pre-Treatment", "Post-Treatment")
    )
  )

summary_dynamic_results <- all_dynamic_results %>%
  dplyr::group_by(time_periods) %>%
  dplyr::summarise(
    mean_estimate = mean(estimate, na.rm = TRUE),
    mean_ci_lower = mean(conf.low, na.rm = TRUE),
    mean_ci_upper = mean(conf.high, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  dplyr::mutate(
    period = factor(
      ifelse(time_periods < 0, "Pre-Treatment", "Post-Treatment"),
      levels = c("Pre-Treatment", "Post-Treatment")
    )
  )

summary_dynamic_results

```

```{r}
# Step 8: Plot Dynamic ATT (with mean estimate and simultaneous CI)
plot_dynamic_ATT_prematched <- ggplot2::ggplot(summary_dynamic_results, ggplot2::aes(x = time_periods, y = mean_estimate, color = period)) +
  
  ggplot2::geom_line(data = all_dynamic_results,
                     ggplot2::aes(x = time_periods, y = estimate, group = run),
                     color = "gray50", alpha = 0.4, linewidth = 0.75) +

  ggplot2::geom_point(size = 2) +
  ggplot2::geom_errorbar(ggplot2::aes(ymin = mean_ci_lower, ymax = mean_ci_upper), width = 0.3) +

  ggplot2::geom_hline(yintercept = 0, color = "black") +
  ggplot2::geom_vline(xintercept = 0, color = "black", linetype = "dashed", alpha = 0.2) +

  ggplot2::scale_color_manual(
    values = c("Pre-Treatment" = "#855C75", "Post-Treatment" = "#D9AF6B"),
    name = "Treatment Period",
    labels = c("Before Treatment", "After Treatment")
  ) +

  ggplot2::labs(
    title = NULL,
    x = "Years Relative to Treatment",
    y = "Average Treatment Effect (with 95% CI)",
    caption = "Gray lines represent individual model estimates across iterations"
  ) +

  ggplot2::scale_y_continuous(
    breaks = seq(-3, 1, by = 0.5),
    minor_breaks = seq(-3, 1, by = 0.25),
    labels = scales::label_percent(scale = 1)
  ) +
  
  ggplot2::scale_x_continuous(
    breaks = seq(-12, 8, by = 2),
    minor_breaks = seq(-13, 8, by = 1)
  ) +

  ggplot2::theme_minimal() +
  ggplot2::theme(
    legend.position = "bottom"
  )

# Print
plot_dynamic_ATT_prematched

# Save
# ggplot2::ggsave(
#   "images/plot_dynamic_ATT_prematched.png",
#   plot = plot_dynamic_ATT_prematched,
#   width = 12, height = 5, dpi = 300
# )

```
```{r}
# Step 1: Compute overall ATT for each model using aggte(..., type = "simple")
att_overall_results <- map_df(att_results_list, function(x) {
  broom::tidy(x$simple_effect)
}) %>%
  rename(
    att_estimate = estimate,
    att_se = std.error
  ) %>%
  mutate(
    ci_lower = att_estimate - 1.96 * att_se,
    ci_upper = att_estimate + 1.96 * att_se
  ) %>%
  filter(!is.na(att_estimate))

# Step 2: Calculate summary statistics
summary_table <- tibble::tibble(
  Statistic = c("Min", "Q1", "Median", "Mean", "Q3", "Max"),
  `ATT Estimate` = c(
    min(att_overall_results$att_estimate, na.rm = TRUE),
    quantile(att_overall_results$att_estimate, 0.25, na.rm = TRUE),
    median(att_overall_results$att_estimate, na.rm = TRUE),
    mean(att_overall_results$att_estimate, na.rm = TRUE),
    quantile(att_overall_results$att_estimate, 0.75, na.rm = TRUE),
    max(att_overall_results$att_estimate, na.rm = TRUE)
  ),
  `Standard Error` = c(
    min(att_overall_results$att_se, na.rm = TRUE),
    quantile(att_overall_results$att_se, 0.25, na.rm = TRUE),
    median(att_overall_results$att_se, na.rm = TRUE),
    mean(att_overall_results$att_se, na.rm = TRUE),
    quantile(att_overall_results$att_se, 0.75, na.rm = TRUE),
    max(att_overall_results$att_se, na.rm = TRUE)
  ),
  `CI Lower` = c(
    min(att_overall_results$ci_lower, na.rm = TRUE),
    quantile(att_overall_results$ci_lower, 0.25, na.rm = TRUE),
    median(att_overall_results$ci_lower, na.rm = TRUE),
    mean(att_overall_results$ci_lower, na.rm = TRUE),
    quantile(att_overall_results$ci_lower, 0.75, na.rm = TRUE),
    max(att_overall_results$ci_lower, na.rm = TRUE)
  ),
  `CI Upper` = c(
    min(att_overall_results$ci_upper, na.rm = TRUE),
    quantile(att_overall_results$ci_upper, 0.25, na.rm = TRUE),
    median(att_overall_results$ci_upper, na.rm = TRUE),
    mean(att_overall_results$ci_upper, na.rm = TRUE),
    quantile(att_overall_results$ci_upper, 0.75, na.rm = TRUE),
    max(att_overall_results$ci_upper, na.rm = TRUE)
  )
) %>%
  mutate(across(where(is.numeric), ~ round(.x, 2)))

# Print full table
print(summary_table)

# Step 3: Brief version of the summary
summary_table_brief <- summary_table %>%
  filter(Statistic == "Mean") %>%
  select(
    `ATT Estimate`,
    `Standard Error`,
    `CI Lower`,
    `CI Upper`
  )

print(summary_table_brief)

# Step 4: Plot histogram of ATT estimates
plot_histogram_overall_ATT_prematched <- ggplot(att_overall_results, aes(x = att_estimate)) +
  geom_histogram(binwidth = 0.02, fill = "#D9AF6B", alpha = 0.7, color = "black") +
  geom_vline(
    xintercept = mean(att_overall_results$att_estimate, na.rm = TRUE),
    linetype = "dashed", color = "#855C75", linewidth = 1.5
  ) +
  annotate(
    "text",
    x = mean(att_overall_results$att_estimate, na.rm = TRUE),
    y = Inf, vjust = 5, hjust = 1.3,
    label = "Mean ATT", color = "#855C75", fontface = "italic", size = 5
  ) +
  labs(
    title = NULL,
    x = "Average Treatment Effect (ATT)",
    y = "Number of Model Runs"
  ) +
  scale_x_continuous(
    labels = scales::label_percent(scale = 1),
    breaks = scales::pretty_breaks(n = 6)
  ) +
  scale_y_continuous(
    breaks = seq(0, 20, by = 5),
    limits = c(0, 20),
    minor_breaks = seq(0, 20, by = 1)
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12)
  )

# Print plot
plot_histogram_overall_ATT_prematched

# Save the plot (commented out as per instruction)
# ggsave("images/plot_overall_ATT_prematched.png",
#        plot = plot_histogram_overall_ATT_prematched,
#        width = 12, height = 5, dpi = 300)

# Step 5: Output LaTeX table (commented, manual use)
# cat(knitr::kable(summary_table, format = "latex", booktabs = TRUE, caption = "Summary of ATT Estimates and Confidence Intervals"))

```
## Combine Three Models into a Facet Plot
### Merge results for plotting
```{r}
# Default DR Model
df_did_full_DR <- broom::tidy(CS_baseline_DR_dynamic_effect) %>%
  rename(time_periods = event.time) %>%
  mutate(
    ci_lower = estimate - 1.96 * std.error,
    ci_upper = estimate + 1.96 * std.error,
    period = factor(ifelse(time_periods < 0, "Pre-Treatment", "Post-Treatment"), 
                    levels = c("Pre-Treatment", "Post-Treatment")),
    model = "Default DR Model"
  ) %>%
  select(time_periods, estimate, ci_lower, ci_upper, period, model)

# Basic OR Model
df_did_full_OR <- broom::tidy(CS_baseline_OR_dynamic_effect) %>%
  rename(time_periods = event.time) %>%
  mutate(
    ci_lower = estimate - 1.96 * std.error,
    ci_upper = estimate + 1.96 * std.error,
    period = factor(ifelse(time_periods < 0, "Pre-Treatment", "Post-Treatment"), 
                    levels = c("Pre-Treatment", "Post-Treatment")),
    model = "Basic OR Model"
  ) %>%
  select(time_periods, estimate, ci_lower, ci_upper, period, model)

# Pre-Matched DR Model
summary_dynamic_results_labeled <- summary_dynamic_results %>%
  rename(
    estimate = mean_estimate,
    ci_lower = mean_ci_lower,
    ci_upper = mean_ci_upper
  ) %>%
  mutate(
    model = "Pre-Matched DR Model",
    period = factor(ifelse(time_periods < 0, "Pre-Treatment", "Post-Treatment"),
                    levels = c("Pre-Treatment", "Post-Treatment"))
  ) %>%
  select(time_periods, estimate, ci_lower, ci_upper, period, model)

# Combine into one dataset
df_combined_models <- bind_rows(
  df_did_full_DR,
  df_did_full_OR,
  summary_dynamic_results_labeled
)

# Gray lines (individual pre-matched runs)
all_dynamic_results_labeled <- all_dynamic_results %>%
  mutate(
    model = "Pre-Matched DR Model",
    period = factor(ifelse(time_periods < 0, "Pre-Treatment", "Post-Treatment"),
                    levels = c("Pre-Treatment", "Post-Treatment"))
  )

```

### Plot all models combined
```{r}
plot_combined_models <- ggplot() +
  geom_line(
    data = all_dynamic_results_labeled,
    aes(x = time_periods, y = estimate, group = run),
    color = "gray80", alpha = 0.3, linewidth = 0.75
  ) +
  geom_point(
    data = df_combined_models,
    aes(x = time_periods, y = estimate, color = period),
    size = 3
  ) +
  geom_errorbar(
    data = df_combined_models,
    aes(x = time_periods, ymin = ci_lower, ymax = ci_upper, color = period),
    width = 0.3, linewidth = 1.2
  ) +
  geom_hline(yintercept = 0, color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", alpha = 0.2) +
  scale_color_manual(
    values = c("Pre-Treatment" = "#D9AF6B", "Post-Treatment" = "#855C75"),
    name = "Treatment Period",
    labels = c("Before Treatment", "After Treatment")
  ) +
  labs(
    title = NULL,
    x = "Years Relative to Treatment",
    y = "Average Treatment Effect (with 95% CI)",
    caption = "Gray lines represent individual model estimates across iterations"
  ) +
  scale_y_continuous(
    breaks = seq(-3, 1, by = 0.5),
    minor_breaks = seq(-3, 1, by = 0.25),
    labels = scales::label_percent(scale = 1)
  ) +
  scale_x_continuous(
    breaks = seq(-12, 8, by = 2),
    minor_breaks = seq(-13, 8, by = 1)
  ) +
  facet_wrap(~ model, nrow = 1, scales = "fixed") +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "bottom",
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 14),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    strip.text = element_text(size = 16, face = "bold"),
    plot.caption = element_text(size = 12)
  )

# Show plot
plot_combined_models

# --- Save plot (commented out for now) ---
# ggsave("images/plot_combined_models_facet.png", plot_combined_models,
#        width = 12, height = 5, dpi = 300)

```

### Robustness Tests: Placebo Tests

```{r}
set.seed(123)  # For reproducibility

# Step 1: Keep only never-treated units
df_control_only <- df_CS_model_preparation %>%
  filter(year_of_closure == 0)

# Step 2: Randomly select a subset of control units for pseudo-treatment
pseudo_treated_ids <- df_control_only %>%
  distinct(ARS) %>%
  slice_sample(prop = 0.1)  # Randomly select 10% of units

# Step 3: Assign random treatment years (2010–2020)
pseudo_treatment_years <- pseudo_treated_ids %>%
  mutate(pseudo_treatment_year = sample(2010:2020, n(), replace = TRUE))

# Step 4: Merge random years back into control sample
df_placebo_random_years <- df_control_only %>%
  left_join(pseudo_treatment_years, by = "ARS") %>%
  mutate(
    year_of_closure_placebo = if_else(is.na(pseudo_treatment_year), 0, pseudo_treatment_year)
  )

# Step 5: Estimate placebo ATT
att_placebo_random_years <- att_gt(
  yname = "employment_level",
  tname = "Year",
  idname = "ARS",
  gname = "year_of_closure_placebo",
  data = df_placebo_random_years,
  xformla = ~ RegioStaR4from5,
  control_group = "nevertreated",
  anticipation = 0
)

# Step 6: Aggregate dynamic ATT
agg_placebo_random_years <- aggte(
  att_placebo_random_years,
  type = "dynamic",
  min_e = -10,
  max_e = 8,
  bstrap = TRUE
)

# Summary of placebo
summary(agg_placebo_random_years)

# Optional plot
# ggdid(agg_placebo_random_years)

```

```{r}
# Step 1: Subset to relevant units
df_placebo_pre2015 <- df_CS_model_preparation %>%
  filter(
    treatment_status_spillover == "control" |
    (treatment_status_spillover == "direct_treated" & year_of_closure >= 2016)
  ) %>%
  mutate(
    year_of_closure_placebo = if_else(treatment_status_spillover == "direct_treated", 2011, 0)
  ) %>%
  filter(Year <= 2015)  # Keep only pre-2015

# Optional check
table(df_placebo_pre2015$year_of_closure_placebo)

# Step 2: Estimate placebo ATT
att_placebo_pre2015 <- att_gt(
  yname = "employment_level",
  tname = "Year",
  idname = "ARS",
  gname = "year_of_closure_placebo",
  data = df_placebo_pre2015,
  xformla = ~ RegioStaR4from5,
  control_group = "nevertreated",
  anticipation = 0
)

# Step 3: Aggregate placebo dynamic ATT
att_placebo_pre2015_dynamic <- aggte(
  att_placebo_pre2015,
  type = "dynamic",
  na.rm = TRUE,
  bstrap = TRUE
)

# Step 4: Summary
summary(att_placebo_pre2015_dynamic)

# Optional plot
# ggdid(att_placebo_pre2015_dynamic)

```


```{r}
# Random timing placebo
df_placebo_random <- broom::tidy(agg_placebo_random_years) %>%
  mutate(
    period = factor(ifelse(event.time < 0, "Pre-Treatment", "Post-Treatment"),
                    levels = c("Pre-Treatment", "Post-Treatment")),
    model = "Random Placebo Timing"
  )

# Fixed 2011 placebo
df_placebo_2011 <- broom::tidy(att_placebo_pre2015_dynamic) %>%
  mutate(
    period = factor(ifelse(event.time < 0, "Pre-Treatment", "Post-Treatment"),
                    levels = c("Pre-Treatment", "Post-Treatment")),
    model = "Placebo Closure Year = 2011"
  )

# Combine
df_placebo_combined <- bind_rows(df_placebo_random, df_placebo_2011)

```

```{r}
plot_placebo_facet <- ggplot(df_placebo_combined, aes(x = event.time, y = estimate, color = period)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.3, linewidth = 1.2) +
  geom_hline(yintercept = 0, color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", alpha = 0.2) +
  facet_wrap(~ model, nrow = 1, scales = "free_x") +
  scale_color_manual(
    values = c(
      "Pre-Treatment" = "#D9AF6B",
      "Post-Treatment" = "#855C75"
    ),
    name = "Treatment Period",
    labels = c("Before Placebo Treatment", "After Placebo Treatment")
  ) +
  labs(
    title = NULL,
    x = "Years Relative to Placebo Treatment",
    y = "Estimated ATT (with 95% CI)"
  ) +
  scale_y_continuous(
    limits = c(-2, 2),
    breaks = seq(-2, 2, by = 0.5),
    minor_breaks = seq(-2, 2, by = 0.25),
    labels = scales::label_percent(scale = 1)
  ) +
  scale_x_continuous(
    breaks = seq(-12, 8, by = 2),
    minor_breaks = seq(-13, 8, by = 1)
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    panel.spacing = unit(4, "lines"),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 14),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    strip.text = element_text(size = 16, face = "bold")
  )

plot_placebo_facet

# Commented out: Saving the plot
# ggsave("images/plot_placebo_facet.png",
#        width = 12, height = 5, dpi = 300)

```


### Robustness Tests: Subgroup Analyses
#### 2-Type Municipality Typology (Urban vs Rural Regions)
```{r}
# Step 1: Estimate ATT separately for each RegioStaR2 group
att_results_by_group_2 <- list()

for (muni_type in unique(df_CS_model_preparation$RegioStaR2)) {
  
  # Subset data for municipality type
  df_subset <- df_CS_model_preparation %>%
    dplyr::filter(RegioStaR2 == muni_type, year_of_closure < 2021)
  
  # Estimate ATT
  att_model <- did::att_gt(
    yname = "employment_level",
    tname = "Year",
    idname = "ARS",
    gname = "year_of_closure",
    data = df_subset,
    xformla = ~ RegioStaR6from7,
    control_group = "nevertreated",
    anticipation = 0
  )
  
  # Compute dynamic and simple overall effects
  att_dynamic <- did::aggte(
    att_model, 
    type = "dynamic",
    max_e = 8,
    bstrap = TRUE,
    na.rm = TRUE
  )
  
  att_simple <- did::aggte(
    att_model,
    type = "simple",
    bstrap = TRUE,
    na.rm = TRUE
  )
  
  # Save results
  att_results_by_group_2[[muni_type]] <- list(
    att_model = att_model,
    dynamic_effect = att_dynamic,
    simple_effect = att_simple
  )
}

# Step 2: Collect dynamic ATT results across groups
all_dynamic_results_by_group_2 <- purrr::map_df(names(att_results_by_group_2), function(muni_type) {
  broom::tidy(att_results_by_group_2[[muni_type]]$dynamic_effect) %>%
    dplyr::mutate(
      municipality_type = muni_type,
      time_periods = event.time,
      period = factor(
        dplyr::if_else(event.time < 0, "Pre-Treatment", "Post-Treatment"),
        levels = c("Pre-Treatment", "Post-Treatment")
      )
    )
}) %>%
  dplyr::mutate(
    municipality_type = dplyr::recode(municipality_type,
      "1" = "Urban Region",
      "2" = "Rural Region"
    )
  )

# Step 3: Collect simple ATT results across groups
overall_treatment_effects_by_group_2 <- purrr::map_df(names(att_results_by_group_2), function(muni_type) {
  broom::tidy(att_results_by_group_2[[muni_type]]$simple_effect) %>%
    dplyr::mutate(municipality_type = muni_type)
}) %>%
  dplyr::rename(
    att_estimate = estimate,
    att_se = std.error,
    ci_lower = conf.low,
    ci_upper = conf.high
  ) %>%
  dplyr::select(municipality_type, att_estimate, att_se, ci_lower, ci_upper) %>%
  dplyr::mutate(
    municipality_type = dplyr::recode(municipality_type,
      "1" = "Urban Region",
      "2" = "Rural Region"
    )
  )

# Display simple treatment effects
overall_treatment_effects_by_group_2

```


```{r}
### Dynamic ATT Plot by Municipality Type

# Step 4: Prepare for plotting
all_dynamic_results_by_group_2 <- all_dynamic_results_by_group_2 %>%
  dplyr::mutate(
    group_period = dplyr::case_when(
      municipality_type == "Urban Region" & period == "Pre-Treatment" ~ "Urban Region - Pre",
      municipality_type == "Urban Region" & period == "Post-Treatment" ~ "Urban Region - Post",
      municipality_type == "Rural Region" & period == "Pre-Treatment" ~ "Rural Region - Pre",
      municipality_type == "Rural Region" & period == "Post-Treatment" ~ "Rural Region - Post"
    )
  )

# Define custom color palette
custom_colors <- c(
  "Urban Region - Pre" = colorspace::lighten("#6A3D9A", amount = 0.25),  # Lighter purple
  "Urban Region - Post" = "#6A3D9A",                                     # Darker purple
  "Rural Region - Pre" = colorspace::lighten("#B15928", amount = 0.25),   # Lighter brown
  "Rural Region - Post" = "#B15928"                                      # Darker brown
)

# Step 5: Plot dynamic ATT by municipality type
plot_dynamic_ATT_combined <- ggplot2::ggplot(all_dynamic_results_by_group_2, 
                                  ggplot2::aes(x = time_periods, y = estimate, color = group_period)) +
  
  ggplot2::geom_point(size = 3, position = ggplot2::position_dodge(width = 0.5)) +
  
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = conf.low, ymax = conf.high),
    width = 0.5,
    position = ggplot2::position_dodge(width = 0.5),
    linewidth = 1.3
  ) +
  
  ggplot2::geom_hline(yintercept = 0, color = "black") +
  ggplot2::geom_vline(xintercept = 0, color = "black", linetype = "dashed", alpha = 0.2) +
  
  ggplot2::scale_color_manual(
    values = custom_colors,
    breaks = c("Urban Region - Post", "Rural Region - Post"),
    labels = c("Urban Region", "Rural Region"),
    name = "Municipality Type\n(Lighter Shades = Pre-Treatment)"
  ) +
  
  ggplot2::labs(
    title = NULL,
    x = "Years Relative to Treatment",
    y = "Average Treatment Effect (with 95% CI)"
  ) +
  
  ggplot2::scale_y_continuous(
    breaks = seq(-3, 1, by = 0.5),
    minor_breaks = seq(-3, 1, by = 0.25),
    labels = scales::label_percent(scale = 1)
  ) +
  
  ggplot2::scale_x_continuous(
    breaks = seq(-12, 8, by = 2),
    minor_breaks = seq(-13, 8, by = 1)
  ) +
  
  ggplot2::theme_minimal() +
  ggplot2::theme(
    legend.position = "bottom"
  )

# Display the plot
plot_dynamic_ATT_combined

```

##Robustness Tests: Allowing for Anticipation Effect

```{r}
# Step 1: Estimate ATT allowing for 1-year anticipation
CS_anticipation_results <- att_gt(
  yname = "employment_level",
  tname = "Year",
  idname = "ARS",
  gname = "year_of_closure",
  data = df_CS_model_preparation %>%
    dplyr::filter(year_of_closure < 2021),
  xformla = ~ RegioStaR4from5,
  control_group = "nevertreated",
  anticipation = 1
)

# Step 2: Compute dynamic ATT
CS_anticipation_dynamic_effect <- aggte(
  CS_anticipation_results,
  type = "dynamic",
  max_e = 8,
  bstrap = TRUE,
  na.rm = TRUE
)

# Step 3: Compute simple overall ATT
CS_anticipation_simple_effect <- aggte(
  CS_anticipation_results,
  type = "simple",
  bstrap = TRUE,
  na.rm = TRUE
)

# Step 4: Tidy dynamic results
CS_anticipation_dynamic_data <- broom::tidy(CS_anticipation_dynamic_effect) %>%
  mutate(
    time_periods = event.time,
    period = factor(
      ifelse(event.time < 0, "Pre-Treatment", "Post-Treatment"),
      levels = c("Pre-Treatment", "Post-Treatment")
    )
  )

# Step 5: Store all results
CS_anticipation_results_combined <- list(
  att_model = CS_anticipation_results,
  dynamic_effect = CS_anticipation_dynamic_effect,
  simple_effect = CS_anticipation_simple_effect
)

# Optional: Display summary
CS_anticipation_simple_effect
CS_anticipation_dynamic_data

```

```{r}
# --- Default DR Model (no anticipation) ---
model_no_anticipation_df <- broom::tidy(CS_baseline_DR_dynamic_effect) %>%
  mutate(model = "Without Anticipation (Default)")

# --- DR Model allowing anticipation ---
model_anticipation_1_df <- broom::tidy(CS_anticipation_dynamic_effect) %>%
  mutate(model = "Allowing 1-Year Anticipation")

# --- Combine both models ---
df_combined_models_test_anticipation <- bind_rows(
  model_no_anticipation_df,
  model_anticipation_1_df
) %>%
  mutate(
    period = factor(
      ifelse(event.time < 0, "Pre-Treatment", "Post-Treatment"),
      levels = c("Pre-Treatment", "Post-Treatment")
    ),
    model = factor(
      model,
      levels = c("Without Anticipation (Default)", "Allowing 1-Year Anticipation")
    )
  )

```

```{r}
plot_dynamic_ATT_anticipation <- ggplot(df_combined_models_test_anticipation, 
                                        aes(x = event.time, y = estimate, color = period)) +
  
  geom_point(size = 3, position = position_dodge(width = 0.5)) +
  geom_errorbar(
    aes(ymin = conf.low, ymax = conf.high),
    width = 0.4,
    position = position_dodge(width = 0.5),
    linewidth = 1.2
  ) +

  geom_hline(yintercept = 0, color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", alpha = 0.2) +

  facet_wrap(~ model, nrow = 1) +

  scale_color_manual(
    values = c(
      "Pre-Treatment" = "#D9AF6B",
      "Post-Treatment" = "#855C75"
    ),
    name = "Treatment Period",
    labels = c("Before Treatment", "After Treatment")
  ) +

  labs(
    title = NULL,
    x = "Years Relative to Treatment",
    y = "Average Treatment Effect (with 95% CI)"
  ) +

  scale_y_continuous(
    breaks = seq(-3, 1, by = 0.5),
    minor_breaks = seq(-3, 1, by = 0.25),
    labels = scales::label_percent(scale = 1)
  ) +
  scale_x_continuous(
    breaks = seq(-12, 8, by = 2),
    minor_breaks = seq(-13, 8, by = 1)
  ) +

  theme_minimal() +
  theme(
    legend.position = "bottom",
    panel.spacing = unit(4, "lines"),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 14),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    strip.text = element_text(size = 16, face = "bold")
  )

plot_dynamic_ATT_anticipation

# Commented out saving the plot
# ggsave("images/plot_dynamic_ATT_anticipation.png",
#        width = 12, height = 5, dpi = 300)

```

### Robustness Test: Including vs Excluding Spillover Units

```{r}
# Step 1: Prepare the robustness dataset (including spillover units)
df_CS_model_preparation_robustness_spillover <- df_combined_hospital_data_employment_enriched %>%
  filter(
    treatment_status_spillover %in% c("control", "direct_treated", "spillover")
  ) %>%
  mutate(
    ARS = as.numeric(ARS),
    year_of_closure = as.numeric(as.character(year_of_closure)),
    year_of_closure = ifelse(is.na(year_of_closure), 0, year_of_closure)
  )

```

```{r}
# Step 2: Estimate ATT using att_gt (with spillover units)
CS_baseline_spillover_results <- att_gt(
  yname = "employment_level",              
  tname = "Year",                          
  idname = "ARS",                          
  gname = "year_of_closure",               
  data = df_CS_model_preparation_robustness_spillover %>%
    filter(year_of_closure < 2021),
  xformla = ~ RegioStaR4from5,
  control_group = "nevertreated",
  anticipation = 0
)

# Step 3: Compute dynamic ATT
CS_baseline_spillover_dynamic_effect <- aggte(
  CS_baseline_spillover_results,
  type = "dynamic",
  max_e = 8,
  bstrap = TRUE,
  na.rm = TRUE
)

# Step 4: Compute simple overall ATT
CS_baseline_spillover_simple_effect <- aggte(
  CS_baseline_spillover_results,
  type = "simple",
  bstrap = TRUE,
  na.rm = TRUE
)

# Step 5: Tidy dynamic results for plotting
CS_baseline_spillover_dynamic_data <- broom::tidy(CS_baseline_spillover_dynamic_effect) %>%
  mutate(
    time_periods = event.time,
    period = factor(
      ifelse(event.time < 0, "Pre-Treatment", "Post-Treatment"),
      levels = c("Pre-Treatment", "Post-Treatment")
    )
  )

# Step 6: Store all results
CS_baseline_spillover_results_combined <- list(
  att_model = CS_baseline_spillover_results,
  dynamic_effect = CS_baseline_spillover_dynamic_effect,
  simple_effect = CS_baseline_spillover_simple_effect
)

# Optional: Display results
CS_baseline_spillover_simple_effect
CS_baseline_spillover_dynamic_data

```

```{r}
# Step 1: Tidy and label the model results
spillover_excluded_df <- broom::tidy(CS_baseline_DR_dynamic_effect) %>%
  mutate(model = "Spillover Units Excluded")

spillover_included_df <- broom::tidy(CS_baseline_spillover_dynamic_effect) %>%
  mutate(model = "Spillover Units Included")

# Step 2: Combine results
df_combined_models_test_spillover <- bind_rows(
  spillover_excluded_df,
  spillover_included_df
) %>%
  mutate(
    period = factor(
      ifelse(event.time < 0, "Pre-Treatment", "Post-Treatment"),
      levels = c("Pre-Treatment", "Post-Treatment")
    ),
    model = factor(model, levels = c("Spillover Units Excluded", "Spillover Units Included"))
  )

```

```{r}
plot_spillover_comparison <- ggplot(df_combined_models_test_spillover, 
                                    aes(x = event.time, y = estimate, color = period)) +

  geom_point(size = 3, position = position_dodge(width = 0.5)) +
  geom_errorbar(
    aes(ymin = conf.low, ymax = conf.high),
    width = 0.4,
    position = position_dodge(width = 0.5),
    linewidth = 1.2
  ) +

  geom_hline(yintercept = 0, color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", alpha = 0.2) +

  facet_wrap(~ model, nrow = 1) +

  scale_color_manual(
    values = c(
      "Pre-Treatment" = "#D9AF6B",
      "Post-Treatment" = "#855C75"
    ),
    name = "Treatment Period",
    labels = c("Before Treatment", "After Treatment")
  ) +

  labs(
    title = NULL,
    x = "Years Relative to Treatment",
    y = "Average Treatment Effect (with 95% CI)"
  ) +

  scale_y_continuous(
    breaks = seq(-3, 1, by = 0.5),
    minor_breaks = seq(-3, 1, by = 0.25),
    labels = scales::label_percent(scale = 1)
  ) +

  scale_x_continuous(
    breaks = seq(-12, 8, by = 2),
    minor_breaks = seq(-13, 8, by = 1)
  ) +

  theme_minimal() +
  theme(
    legend.position = "bottom",
    panel.spacing = unit(4, "lines"),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 14),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    strip.text = element_text(size = 16, face = "bold")
  )

# Display the plot
plot_spillover_comparison

# Saving is commented out for now
# ggsave("images/plot_spillover_comparison.png",
#        width = 12, height = 5, dpi = 300)

```

